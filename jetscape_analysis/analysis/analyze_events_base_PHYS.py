#!/usr/bin/env python3

""" Base class to analyze a JETSCAPE output file: do jet-finding and produce a ROOT file for each pt-hat bin.

You should create a user class that inherits from this one. See analyze_events_PHYS.py for an example.

The outputdir should contain the JETSCAPE output files in the structure generated by the PHYS WG output structure.

See README for pre-requisites.

.. codeauthor:: James Mulligan <james.mulligan@berkeley.edu>, UC Berkeley
"""

from __future__ import print_function

# General
import os
import subprocess
import sys
import tqdm
import yaml

# Analysis
import itertools
import ROOT

# Fastjet via python (from external library heppy)
import fjext

from jetscape_analysis.analysis import scale_histograms
from jetscape_analysis.analysis.reader import reader_ascii_parsed, parse_ascii
from jetscape_analysis.base import common_base

################################################################
class AnalyzeJetscapeEvents_BasePHYS(common_base.CommonBase):

    # ---------------------------------------------------------------
    # Constructor
    # ---------------------------------------------------------------
    def __init__(self, config_file="", input_file="", output_dir="", **kwargs):
        super(AnalyzeJetscapeEvents_BasePHYS, self).__init__(**kwargs)
        self.config_file = config_file
        self.output_dir = output_dir
        
        self.input_file_hadrons = input_file
        self.input_file_partons = ''
            
        # Get pt-hat from filename
        filename = self.input_file_hadrons.split('/')[-1]
        self.suffix = filename.split('Bin')[1].split('.')[0]
        self.pt_hat_min = int(self.suffix.split('_')[0])
        self.pt_hat_max = int(self.suffix.split('_')[1])
        
        # Get pt-hat scale factor from file in same directory
        self.input_dir = os.path.dirname(input_file)
        pt_hat_filename = os.path.join(self.input_dir, 'SigmaHardBin{}_{}.out'.format(self.pt_hat_min, self.pt_hat_max))
        with open(pt_hat_filename) as f:
            first_line = f.readline()
            self.pt_hat_xsec = float(first_line.split(' ')[0])
            self.pt_hat_xsec_err = float(first_line.split(' ')[1])

        self.initialize_config()

    # ---------------------------------------------------------------
    # Initialize config file into class members
    # ---------------------------------------------------------------
    def initialize_config(self):

        # Read config file
        with open(self.config_file, 'r') as stream:
            config = yaml.safe_load(stream)
            
        self.debug_level = config['debug_level']
        self.n_event_max = config['n_event_max']
        self.events_per_chunk = config['events_per_chunk']
        self.reader_type = config['reader']
        self.progress_bar = config['progress_bar']
        self.scale_histograms = config['scale_histograms']
        
        # Find pt-hat bin index
        self.pt_hat_bins = config['pt_hat_bins']
        self.n_pt_hat_bins = len(self.pt_hat_bins) - 1
        for i,bin in enumerate(self.pt_hat_bins):
            if bin == self.pt_hat_min:
                self.pt_hat_bin = i
                
        # Create output dir
        self.output_dir = os.path.join(self.output_dir, str(self.pt_hat_bin))
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)
        
        self.event_id = 0

    # ---------------------------------------------------------------
    # Main processing function
    # ---------------------------------------------------------------
    def analyze_jetscape_events(self):
    
        print('Analyzing pt-hat: {} - {} ...'.format(self.pt_hat_min, self.pt_hat_max))
    
        # Read JETSCAPE output, get hadrons, do jet finding, and write histograms to ROOT file
        self.run_jetscape_analysis()

        # Scale histograms according to pthard bins cross-section
        if self.scale_histograms:
            print("Scaling pt-hat bin...")
            scale_histograms.scale_histograms(self.output_dir, self.pt_hat_bin, bRemoveOutliers=False)

    # ---------------------------------------------------------------
    # Main processing function for a single pt-hat bin
    # ---------------------------------------------------------------
    def run_jetscape_analysis(self):

        # Initialize output objects
        self.initialize_output_objects()
        
        if self.progress_bar:
            pbar = tqdm.tqdm(range(self.n_event_max))

        # Create reader class for each chunk of events, and iterate through each chunk
        # The parser returns an awkward array of events
        for event_chunk in parse_ascii.read(filename=self.input_file_hadrons,
                                            events_per_chunk=self.events_per_chunk):

            # Iterate through events
            # Construct reader objects
            self.reader = reader_ascii_parsed.ReaderAsciiParsed(event_chunk)
            # Use generator function to loop through events
            for event in self.reader(n_events=len(event_chunk)):
            
                if not event:
                    if self.progress_bar:
                        nstop = pbar.n
                        pbar.close()
                        print('End of {} file at event {} '.format(self.reader_type, nstop))
                    else:
                        print('End of {} file.'.format(self.reader_type))
                    break

                # Print and store basic event info
                self.get_event_info(event)
                
                # Call user-defined function to analyze event
                self.analyze_event(event)
                if self.progress_bar:
                    pbar.update()
                else:
                    if self.event_id % 1000 == 0:
                        print('event: {}'.format(self.event_id))

        # Write analysis task output to ROOT file
        self.write_output_objects()

    # ---------------------------------------------------------------
    # Initialize output objects
    # ---------------------------------------------------------------
    def initialize_output_objects(self):

        # Event histograms
        self.hNevents = ROOT.TH1F('hNevents', 'hNevents', self.n_pt_hat_bins, 0, self.n_pt_hat_bins)
        self.hCrossSection = ROOT.TH1F('hCrossSection', 'hCrossSection', self.n_pt_hat_bins, 0, self.n_pt_hat_bins)
        
        # Initialize user-defined output objects
        self.initialize_user_output_objects()
        
    # ---------------------------------------------------------------
    # Get event info
    # ---------------------------------------------------------------
    def get_event_info(self, event):

        self.event_id += 1

    # ---------------------------------------------------------------
    # Save all ROOT histograms and trees to file
    # ---------------------------------------------------------------
    def write_output_objects(self):

        # Fill cross-section
        self.hCrossSection.SetBinContent(self.pt_hat_bin+1, self.pt_hat_xsec)
        self.hCrossSection.SetBinError(self.pt_hat_bin+1, self.pt_hat_xsec_err)
        
        # Set N events
        self.hNevents.SetBinContent(self.pt_hat_bin+1, self.event_id)

        # Save output objects
        outputfilename = os.path.join(self.output_dir, 'AnalysisResults.root')
        fout = ROOT.TFile(outputfilename, 'recreate')
        fout.cd()
        for attr in dir(self):

            obj = getattr(self, attr)

            # Write all ROOT histograms and trees to file
            types = (ROOT.TH1, ROOT.THnBase, ROOT.TTree)
            if isinstance(obj, types):
                obj.Write()
                obj.SetDirectory(0)
                del obj

        fout.Close()
   
    # ---------------------------------------------------------------
    # Fill hadrons into vector of fastjet pseudojets
    #
    # By default, select all particles
    # If select_status='+', select only positive status particles
    # If select_status='-', select only positive status particles
    # ---------------------------------------------------------------
    def fill_fastjet_constituents(self, hadrons, select_status=None):

        if select_status == '-':
            px = [hadron.momentum.px for hadron in hadrons if hadron.status<0]
            py = [hadron.momentum.py for hadron in hadrons if hadron.status<0]
            pz = [hadron.momentum.pz for hadron in hadrons if hadron.status<0]
            e = [hadron.momentum.e for hadron in hadrons if hadron.status<0]
        elif select_status == '+':
            px = [hadron.momentum.px for hadron in hadrons if not hadron.status<0]
            py = [hadron.momentum.py for hadron in hadrons if not hadron.status<0]
            pz = [hadron.momentum.pz for hadron in hadrons if not hadron.status<0]
            e = [hadron.momentum.e for hadron in hadrons if not hadron.status<0]
        else:
            px = [hadron.momentum.px for hadron in hadrons]
            py = [hadron.momentum.py for hadron in hadrons]
            pz = [hadron.momentum.pz for hadron in hadrons]
            e = [hadron.momentum.e for hadron in hadrons]
    
        # Create a vector of fastjet::PseudoJets from arrays of px,py,pz,e
        fj_particles = fjext.vectorize_px_py_pz_e(px, py, pz, e)
        
        # Set pid as user_index
        pid = [hadron.pid for hadron in hadrons]
        for i,p in enumerate(fj_particles):
            fj_particles[i].set_user_index(pid[i])
        
        return fj_particles

    # ---------------------------------------------------------------
    # This function is called once per setting
    # You must implement this
    # ---------------------------------------------------------------
    def initialize_user_output_objects(self):
        raise NotImplementedError('You must implement initialize_user_output_objects()!')
        
    # ---------------------------------------------------------------
    # This function is called once per event (per setting)
    # You must implement this
    # ---------------------------------------------------------------
    def analyze_event(self, event):
        raise NotImplementedError('You must implement analyze_event()!')
